import { demos } from "../demos";
import { normalizeIndent } from "./components";

# Draggable Diagrams workshop

Hey thanks for joining the workshop and trying out Draggable Diagrams! My hope is that this will be a fun and interesting and creative experience. I'm also hoping to learn some things from you, like...

- What kind of diagrams are you dreaming of making? (And how could this system grow to help you make them?)
- What kind of new diagrammy ideas arise from working with this system?
- What is it like to work with this system, and how could I make it better?

Let's jump in!

## Introduction to Draggable Diagrams

Draggable Diagrams (DD) is a framework for making interactive diagrams. "Diagrams" here is potentially broad – it could include diagrams of mathematical structures, weird new controllers, direct-manipulation editors, and other interfaces besides. The unique angle of DD is, as the name implies, making drag-drop interactions easier to implement. It does this with a React-y, state-driven approach. In DD, you write a "render" function that turns underlying state into an SVG drawing. To make an object in this drawing draggable, you need only describe what _new states_ should be accessible by dragging it. DD will pre-render these possible drawings, and use them to guide a drag-drop interaction.

Let's build up some examples. First, a diagram that doesn't do anything.

<LiveEditor
  secretCode={`
    const initialState = {};
  `}
  code={`
    const manipulable = () => (
      <circle
        cx={100}
        cy={100}
        r={50}
        fill="blue"
      />
    );
  `}
/>

This defines a "manipulable" – a particular kind of function that returns React SVG elements using JSX. It looks an awful lot like a React component function, but it isn't one; sorry; no using hooks or anything like that.

But this manipulable doesn't actually do anything. Let's fix that. For a diagram to be interactive, it must have multiple states it can be in. So we will define a state type and an initial state to start at.

(Note: This text-editor gadget doesn't have real TypeScript support so we will only provide types when we feel like it. You'll want to use TypeScript while editing! Copy an existing project from the repo for that.)

<LiveEditor
  code={`
    type State = {
      status: "off" | "on";
    }

    const initialState = { status: "off" };

    const manipulable = ({ state, drag }) => (
      <circle
        transform={translate(state.status === "off" ? [100, 100] : [200, 100])}
        r={50}
        fill="blue"
        data-on-drag={drag(span([{status: "off"}, {status: "on"}]))}
      />
    );

`}
/>

Try dragging the ball left and right! Try letting go of it in the middle! Pretty spunky, huh?

There are a lot of new bits here. First a speed-run through some smaller bits:

- Our diagram's state is very simple: a `status` that can be `"off"` or `"on"`. State should always be an object of some sort. We could've used a boolean but I'm feeling fancy.

- We switched from `cx` and `cy` to `transform`. For something to be draggable in DD, it needs to be positioned using transforms. (This makes a lot of infrastructural logic more uniform, and the system authors are lazy.) To make using transforms easier, we have helpers `translate`, `rotate`, and `scale`.

  In short: anywhere you might ordinarily position a shape with an x & y, you should use `transform={translate(...)}`.

- Here, we use a `transform` that depends on state – `"off"` will be to the left and `"on"` will be to the right. State is provided as an argument to the manipulable.

Now we're ready for the biggest bit: dragging! Dragging is what lets us move into these exciting new states we have. When you attach `data-on-drag` to an SVG element, you are telling DD you want to be able to move between states by dragging the element. You provide a "drag spec" which lists various states that should be accessible by dragging. When you start dragging the element, DD will invisibly render the diagrams of those accessible states, and see where the dragged element ends up. It will use that to synthesize a drag interaction, interpolating between accessible states as you go.

Pieces of this puzzle:

- Every use of `data-on-drag` should look like `data-on-drag={drag(...)}`, using the `drag` function provided as an argument to the manipulable. The `drag` function provides type assistance, and DD will throw an error if you don't use it.

- The argument to `drag` can be a lot of different things. For one, it can be a callback that generates a drag spec lazily. That might be smart for performance, but we don't do that here – we just provide a pre-computed `span` object. That means "I want to be able to drag back and forth between all the states in this list". The main alternative to `span` is `straightTo`. That means "I want to drag straight from my starting state to this other state" – you can return an array of `straightTo`s to tell DD you want a couple disjoint tracks from the starting state to the targets.

With this knowledge we can take on a more involved example: reordering objects.

<LiveEditor
  code={`
    type State = {
      perm: string[];
    };

    const initialState: State = {
      perm: ["A", "B", "C", "D", "E"],
    };

    const TILE_SIZE = 50;

    const manipulable: Manipulable<State> = ({
      state,
      drag,
      draggedId,
    }) => (
      <g transform={translate(50, 50)}>
        {state.perm.map((p, idx) => {
          const isDragged = p === draggedId;
          return (
            <g
              id={p}
              transform={translate(idx * TILE_SIZE, isDragged ? -10 : 0)}
              data-z-index={isDragged ? 1 : 0}
              data-on-drag={drag(() =>
                span(
                  _.range(state.perm.length).map((newIdx) =>
                    produce(state, (draft) => {
                      draft.perm.splice(idx, 1);
                      draft.perm.splice(newIdx, 0, p);
                    }),
                  ),
                )
              )}
            >
              <rect
                width={TILE_SIZE}
                height={TILE_SIZE}
                stroke="black"
                strokeWidth={2}
                fill="white"
              />
              <text
                x={TILE_SIZE / 2}
                y={TILE_SIZE / 2}
                dominantBaseline="middle"
                textAnchor="middle"
                fontSize={20}
                fill="black"
              >
                {p}
              </text>
            </g>
          );
        })}
      </g>
    );
`}
/>

Some important aspects, top to bottom:

- This diagram "lifts" a tile a bit when it's getting dragged. That's possible because DD provides `draggedId` as a function argument, which is set to the `id` attribute of the currently-dragged element, or `null`. The diagram uses this to calculate `isDragged` in a loop and apply effects conditionally.

- `id` is a much bigger deal than just powering `draggedId`. DD uses `id` to connect elements across renderings of different states. If `id` is not provided, DD will use position in the tree structure, which sometimes is all you need. But here, that would fail – we're rendering tiles in order of position, which means the tile in tree position _i_ will change over time. To get drag control and interpolation between positions, you need `id`s!

  - Note that elements are sometimes identified using a combination of `id` & tree position. For instance, the C tile's `<text>` will be identified via the path `C/1`.

  - `id` acts like a global version of React's `key`. I considered adding `key` as a local version, but I haven't run into a need for it yet. Let me know what you think!

- SVG doesn't have z-index. But because elements with `id`s end up "ripped out" of the SVG structure, we can put z-indices on them (with `data-z-index`) to determine their ultimate ordering. Here, we use that to make sure the dragged tile is on top of the others.

- Now the important part: the drag spec attached to `data-on-drag`! Dragging an element of the array should be able to bring you to every possible version of the array where the dragged element is removed and then inserted in a different location. We compute all these possible arrays in the drag spec callback. Specifically, we do so with [Immer](https://immerjs.github.io/immer/)'s `produce` function, which lets you apply mutations to a "draft" to immutably produce a new value. You could also just `structuredClone` the original value and mutate it, or painstakingly use a bunch of `{ ...oldState, newKey: ...}`-type expressions.

I think those are the basics. Hope they make sense.

From here, it's choose-your-own-adventure. There's a lot you can do with just these mechanisms; the [demos](#/demos) page has more examples to guide and inspire you. Below, I'll add quick notes on a few other mechanisms or topics.

## Other topics

### Continuous state

The most novel part of Draggable Diagrams is the "drag between discrete states" thing. But I also added in a pretty nice "drag between continuous states" mechanism, inspired by [Apparatus](https://aprt.us/) and [g9](https://omrelli.ug/g9/). Here's the classic nontrivial example: a crank.

<LiveEditor
  code={`
    type State = {
      angle: number;
    }

    const initialState = { angle: 0 };

    const manipulable = ({ state, drag }) => (
      <g transform={translate(150, 150)}>
        <g transform={rotate(state.angle)}>
          <line
            x2={100}
            stroke="black"
            strokeWidth={4}
          />
          <circle
            transform={translate(100, 0)}
            r={20}
            fill="black"
            data-on-drag={drag(numAtPath(["angle"]))}
          />
        </g>
      </g>
    );

`}
/>

The new part here is `numAtPath` in the drag spec. This means "the drag should control a numeric value located at this path in the state object". Specifically, it will control the numeric value to try to make the dragged object as close to the dragged pointer as possible. (That's numeric minimization!)

A single diagram can have both discrete and continuous drags. Here, edges can be moved discretely between nodes, and nodes can be moved continuously on the canvas:

<DemoEmbed demoId="graph" />

(Really, it should be possible for a single drag to control _both_ discrete and continuous dimensions, but DD doesn't support that yet. I'd love to have a good reason to do so.)

And just for fun here's a continuous drag controlling scale & rotation transforms:

<DemoEmbed demoId="stretchy-rot" />

### setState

If you'd like to more directly move between states, say, in response to a click, you can use `setState`, which is provided as an argument to the manipulable. It's more boring than dragging, but it does still have some tricks up its sleeve...

In this example, we loop through a set of colors (& positions) by clicking:

<LiveEditor
  code={`
    type State = {
      colorIdx: number;
    };

    const initialState: State = { colorIdx: 0 };

    const manipulable: Manipulable<State> = ({ state, setState }) => {
      const colors = ["red", "green", "blue", "yellow"];

      return (
        <rect
          x={50 + 40 * state.colorIdx}
          y={50}
          width={100}
          height={100}
          fill={colors[state.colorIdx]}
          onClick={() => {
            const nextIdx = (state.colorIdx + 1) % colors.length;
            setState({ colorIdx: nextIdx });
          }}
          style={{ cursor: "pointer" }}
        />
      );
    };

`}
/>

`setState` animates! At least by default; you can change this behavior with a second argument, of type:

```
{
  easing?: (t: number) => number;
  seconds?: number;
  immediate?: boolean;
}
```

I haven't used `setState` much. Maybe you will?

### \<foreignObject\>

Continuing the slide into abject normalcy, we should note that you can embed HTML inside your SVGs with `<foreignObject>`. This is probably a useful escape-hatch for, e.g., putting editable text fields into diagrams.

Or for making trending apps:

<DemoEmbed demoId="todo" />

(To be clear: This isn't a DD feature, just a note that we haven't broken `<foreignObject>` yet.)

### Detach + Reattach

[TODO]

## Challenges

[TODO]

<DemoEmbed demoId="inserting-removing-items" />
